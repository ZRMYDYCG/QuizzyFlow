---
globs: server/**/*.ts
description: Backend NestJS code conventions
---

# Backend (NestJS) Code Conventions

## Module Structure

Each feature module in [server/src](mdc:server/src) follows NestJS conventions:

```
[feature]/
├── [feature].controller.ts    # HTTP endpoints
├── [feature].service.ts        # Business logic
├── [feature].module.ts         # Module definition
├── dto/                        # Data Transfer Objects
│   └── [feature].dto.ts
└── schemas/                    # Mongoose schemas
    └── [feature].schema.ts
```

## Controller Pattern

### Basic Controller Structure

```typescript
import { 
  Controller, 
  Get, 
  Post, 
  Body, 
  Param, 
  UseGuards 
} from '@nestjs/common'
import { AuthGuard } from '@/auth/auth.guard'
import { QuestionService } from './question.service'
import { CreateQuestionDto } from './dto/question.dto'

@Controller('api/question')
@UseGuards(AuthGuard)  // Apply auth to all routes
export class QuestionController {
  constructor(private readonly questionService: QuestionService) {}

  @Get()
  async findAll() {
    return this.questionService.findAll()
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.questionService.findOne(id)
  }

  @Post()
  async create(@Body() createQuestionDto: CreateQuestionDto) {
    return this.questionService.create(createQuestionDto)
  }
}
```

### Public Routes

Use the `@Public()` decorator for routes that don't require authentication:

```typescript
import { Public } from '@/auth/decorators/public.decorator'

@Public()
@Post('login')
async login(@Body() loginDto: LoginDto) {
  return this.authService.login(loginDto)
}
```

## Service Pattern

### Business Logic in Services

```typescript
import { Injectable, NotFoundException } from '@nestjs/common'
import { InjectModel } from '@nestjs/mongoose'
import { Model } from 'mongoose'
import { Question } from './schemas/question.schema'
import { CreateQuestionDto } from './dto/question.dto'

@Injectable()
export class QuestionService {
  constructor(
    @InjectModel(Question.name) 
    private questionModel: Model<Question>
  ) {}

  async findAll(): Promise<Question[]> {
    return this.questionModel.find().exec()
  }

  async findOne(id: string): Promise<Question> {
    const question = await this.questionModel.findById(id).exec()
    if (!question) {
      throw new NotFoundException(`Question with ID ${id} not found`)
    }
    return question
  }

  async create(createQuestionDto: CreateQuestionDto): Promise<Question> {
    const created = new this.questionModel(createQuestionDto)
    return created.save()
  }

  async update(id: string, updateDto: CreateQuestionDto): Promise<Question> {
    const updated = await this.questionModel
      .findByIdAndUpdate(id, updateDto, { new: true })
      .exec()
    if (!updated) {
      throw new NotFoundException(`Question with ID ${id} not found`)
    }
    return updated
  }

  async remove(id: string): Promise<void> {
    const result = await this.questionModel.findByIdAndDelete(id).exec()
    if (!result) {
      throw new NotFoundException(`Question with ID ${id} not found`)
    }
  }
}
```

## Schema Definition (Mongoose)

### Define MongoDB Schemas

```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose'
import { HydratedDocument } from 'mongoose'

export type QuestionDocument = HydratedDocument<Question>

@Schema({
  timestamps: true,  // Adds createdAt and updatedAt
})
export class Question {
  @Prop({ required: true })
  title: string

  @Prop({ required: true })
  description: string

  @Prop({ default: false })
  isPublished: boolean

  @Prop({ default: false })
  isStarred: boolean

  @Prop({ default: false })
  isDeleted: boolean

  @Prop({ type: Object })
  components: Record<string, any>

  @Prop()
  userId: string
}

export const QuestionSchema = SchemaFactory.createForClass(Question)
```

## DTO Pattern

### Data Transfer Objects

```typescript
import { 
  IsString, 
  IsBoolean, 
  IsOptional, 
  IsNotEmpty 
} from 'class-validator'

export class CreateQuestionDto {
  @IsString()
  @IsNotEmpty()
  title: string

  @IsString()
  @IsOptional()
  description?: string

  @IsBoolean()
  @IsOptional()
  isPublished?: boolean

  @IsOptional()
  components?: Record<string, any>
}

export class UpdateQuestionDto {
  @IsString()
  @IsOptional()
  title?: string

  @IsString()
  @IsOptional()
  description?: string

  @IsBoolean()
  @IsOptional()
  isPublished?: boolean
}
```

## Module Configuration

### Module Registration

```typescript
import { Module } from '@nestjs/common'
import { MongooseModule } from '@nestjs/mongoose'
import { QuestionController } from './question.controller'
import { QuestionService } from './question.service'
import { Question, QuestionSchema } from './schemas/question.schema'

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Question.name, schema: QuestionSchema }
    ])
  ],
  controllers: [QuestionController],
  providers: [QuestionService],
  exports: [QuestionService],  // Export if used by other modules
})
export class QuestionModule {}
```

## Authentication

### JWT Authentication

The project uses JWT-based authentication via [server/src/auth](mdc:server/src/auth):

```typescript
// In auth.service.ts
async signIn(username: string, password: string) {
  const user = await this.userService.findByUsername(username)
  if (!user || user.password !== password) {
    throw new UnauthorizedException()
  }
  
  const payload = { sub: user._id, username: user.username }
  return {
    access_token: await this.jwtService.signAsync(payload)
  }
}
```

### Auth Guard

Applied globally or per-controller:
```typescript
import { AuthGuard } from '@/auth/auth.guard'

@UseGuards(AuthGuard)
@Controller('api/protected')
export class ProtectedController {}
```

## Error Handling

### HTTP Exception Filter

The project uses a global exception filter at [server/src/http-exeption/http-exception.filter.ts](mdc:server/src/http-exeption/http-exception.filter.ts):

```typescript
import { 
  ExceptionFilter, 
  Catch, 
  ArgumentsHost, 
  HttpException 
} from '@nestjs/common'

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse()
    const status = exception.getStatus()
    
    response.status(status).json({
      statusCode: status,
      message: exception.message,
      timestamp: new Date().toISOString(),
    })
  }
}
```

### Common Exceptions

```typescript
import { 
  NotFoundException, 
  BadRequestException,
  UnauthorizedException,
  ForbiddenException 
} from '@nestjs/common'

// Not found
throw new NotFoundException('Resource not found')

// Bad input
throw new BadRequestException('Invalid input data')

// Auth issues
throw new UnauthorizedException('Invalid credentials')

// Permission denied
throw new ForbiddenException('Access denied')
```

## Response Transformation

### Transform Interceptor

The project uses a global transform interceptor at [server/src/transform/transform.interceptor.ts](mdc:server/src/transform/transform.interceptor.ts) to standardize responses:

```typescript
{
  code: 0,
  data: { /* actual data */ },
  message: 'Success'
}
```

## Environment Configuration

### Using ConfigModule

```typescript
import { ConfigService } from '@nestjs/config'

@Injectable()
export class MyService {
  constructor(private configService: ConfigService) {}

  getDatabaseUrl() {
    return this.configService.get<string>('DATABASE_URL')
  }
}
```

## Testing

### Unit Tests

```typescript
import { Test, TestingModule } from '@nestjs/testing'
import { QuestionService } from './question.service'

describe('QuestionService', () => {
  let service: QuestionService

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [QuestionService],
    }).compile()

    service = module.get<QuestionService>(QuestionService)
  })

  it('should be defined', () => {
    expect(service).toBeDefined()
  })
})
```

## Best Practices

1. **Dependency Injection**: Always use constructor injection
2. **Single Responsibility**: Keep services focused on one domain
3. **Validation**: Use DTOs with class-validator
4. **Error Handling**: Use NestJS exception classes
5. **Async/Await**: Use async/await for asynchronous operations
6. **Type Safety**: Leverage TypeScript types everywhere
7. **Module Organization**: Keep related code in the same module
8. **Environment Variables**: Never hardcode sensitive data

## Database Operations

### Query Best Practices

```typescript
// Use exec() for better error handling
const result = await this.model.findOne({ id }).exec()

// Use lean() for read-only operations (better performance)
const results = await this.model.find().lean().exec()

// Use projection to limit fields
const results = await this.model
  .find()
  .select('title description')
  .exec()

// Use pagination
const results = await this.model
  .find()
  .skip(skip)
  .limit(limit)
  .exec()
```
