---
globs: src/**/*.ts,src/**/*.tsx
description: Frontend code conventions for React TypeScript
---

# Frontend Code Conventions

## TypeScript Guidelines

### Import Ordering
1. External libraries (React, third-party packages)
2. Internal modules using `@/` alias
3. Relative imports
4. Type imports (use `import type` when importing only types)

Example:
```typescript
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { Button } from 'antd'
import { useDispatch, useSelector } from 'react-redux'
import type { FC } from 'react'

import { updateUser } from '@/store/modules/user'
import { useGetUserInfo } from '@/hooks/useGetUserInfo'
import type { IUserState } from '@/store/modules/user'

import './styles.css'
```

### Path Aliases
Always use the `@/` alias for imports from `src/`:
```typescript
// ✅ Good
import { Button } from '@/components/material/question-button'
import { useGetPageInfo } from '@/hooks/useGetPageInfo'

// ❌ Bad
import { Button } from '../../components/material/question-button'
import { useGetPageInfo } from '../hooks/useGetPageInfo'
```

## Component Patterns

### Functional Components
- Use `FC` type from React for function components
- Destructure props in function parameters
- Use proper TypeScript interfaces for props

```typescript
import type { FC } from 'react'

interface ButtonComponentProps {
  label: string
  onClick: () => void
  disabled?: boolean
}

const ButtonComponent: FC<ButtonComponentProps> = ({ 
  label, 
  onClick, 
  disabled = false 
}) => {
  return <button onClick={onClick} disabled={disabled}>{label}</button>
}

export default ButtonComponent
```

### Hooks Usage
- Custom hooks must start with `use`
- Keep hooks in `src/hooks/` directory
- Follow the naming pattern: `useActionName` (e.g., `useGetUserInfo`, `useLoadQuestionData`)

### State Management with Redux

#### Reading State
```typescript
import { useSelector } from 'react-redux'
import type { stateType } from '@/store'

const MyComponent: FC = () => {
  const user = useSelector((state: stateType) => state.user)
  const { componentList } = useSelector(
    (state: stateType) => state.questionComponent.present
  )
  
  // Note: questionComponent uses redux-undo, access via .present
}
```

#### Dispatching Actions
```typescript
import { useDispatch } from 'react-redux'
import { updatePageInfo } from '@/store/modules/pageinfo-reducer'

const MyComponent: FC = () => {
  const dispatch = useDispatch()
  
  const handleUpdate = () => {
    dispatch(updatePageInfo({ title: 'New Title' }))
  }
}
```

#### Undo/Redo Actions
For components with undo/redo support:
```typescript
import { ActionCreators } from 'redux-undo'

const handleUndo = () => {
  dispatch(ActionCreators.undo())
}

const handleRedo = () => {
  dispatch(ActionCreators.redo())
}
```

## Styling Conventions

### TailwindCSS
- Prefer Tailwind utility classes for styling
- Use `clsx` or `cn` utility for conditional classes
- Keep className strings readable (break long strings into multiple lines if needed)

```typescript
import { clsx } from 'clsx'

<div className={clsx(
  'flex items-center justify-between',
  'p-4 rounded-lg border',
  'hover:bg-gray-50 transition-colors',
  isActive && 'bg-blue-50 border-blue-500',
  isDisabled && 'opacity-50 cursor-not-allowed'
)}>
```

### Ant Design Integration
- Import Ant Design components as needed
- Use Ant Design for complex UI patterns (forms, tables, modals)
- Use Radix UI for unstyled primitives when needed

## API Calls

### Using Axios
- API functions are in [src/api](mdc:src/api)
- Organize by domain (user, question, statistics)
- Always handle errors with try/catch or .catch()

```typescript
import { getQuestionList } from '@/api/modules/question'

const loadData = async () => {
  try {
    const data = await getQuestionList()
    // handle data
  } catch (error) {
    console.error('Failed to load questions:', error)
    // handle error
  }
}
```

## Form Handling

### Controlled Components
- Always use controlled components for forms
- Use React state or Redux for form data
- Validate on blur and/or submit

```typescript
const [formData, setFormData] = useState({ name: '', email: '' })

const handleChange = (field: string) => (
  e: React.ChangeEvent<HTMLInputElement>
) => {
  setFormData(prev => ({ ...prev, [field]: e.target.value }))
}

<input 
  value={formData.name} 
  onChange={handleChange('name')} 
/>
```

## Performance Optimization

### Memoization
Use React.memo, useMemo, and useCallback appropriately:
```typescript
import { memo, useMemo, useCallback } from 'react'

// Memoize expensive calculations
const sortedList = useMemo(() => {
  return items.sort((a, b) => a.order - b.order)
}, [items])

// Memoize callbacks passed to children
const handleClick = useCallback(() => {
  console.log('clicked')
}, [])

// Memoize components
export default memo(MyComponent)
```

## Error Handling

### Component Error Boundaries
- Handle async errors gracefully
- Show user-friendly error messages
- Log errors for debugging

### Loading States
Always provide loading feedback:
```typescript
const [loading, setLoading] = useState(false)

if (loading) return <Spin />
```

## Testing Considerations
- Write testable code (pure functions, separated logic)
- Avoid side effects in render
- Keep business logic separate from UI
