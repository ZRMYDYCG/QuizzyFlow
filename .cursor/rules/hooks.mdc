---
globs: src/hooks/**/*.ts
description: Custom hooks development patterns
---

# Custom Hooks Development Guide

## Hook Structure

Custom hooks in [src/hooks](mdc:src/hooks) follow consistent patterns for state management, side effects, and data fetching.

## Naming Convention

All custom hooks MUST:
- Start with `use` prefix
- Use camelCase
- Be descriptive about their purpose

```typescript
// ✅ Good hook names
useGetUserInfo
useLoadQuestionData
useCanvasKeyPress
useNavPage
useManageTheme

// ❌ Bad hook names
getUserInfo    // Missing 'use' prefix
UseTheme       // Should be camelCase
hook           // Not descriptive
```

## Hook Categories

### 1. Data Fetching Hooks

Pattern for loading data from API:

```typescript
// hooks/useLoadQuestionData.ts
import { useState, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { getQuestionById } from '@/api/modules/question'
import type { Question } from '@/api/modules/question'

interface UseLoadQuestionDataReturn {
  loading: boolean
  error: Error | null
  data: Question | null
  refresh: () => void
}

export const useLoadQuestionData = (): UseLoadQuestionDataReturn => {
  const { id } = useParams<{ id: string }>()
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  const [data, setData] = useState<Question | null>(null)
  
  const loadData = async () => {
    if (!id) return
    
    try {
      setLoading(true)
      setError(null)
      const question = await getQuestionById(id)
      setData(question)
    } catch (err) {
      setError(err as Error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    loadData()
  }, [id])
  
  return { loading, error, data, refresh: loadData }
}
```

### 2. State Selector Hooks

Pattern for accessing Redux state:

```typescript
// hooks/useGetComponentInfo.ts
import { useSelector } from 'react-redux'
import type { stateType } from '@/store'
import type { ComponentInfoType } from '@/store/modules/question-component'

interface UseGetComponentInfoReturn {
  componentList: ComponentInfoType[]
  selectedId: string
  selectedComponent: ComponentInfoType | undefined
  copiedComponent: ComponentInfoType | null
}

export const useGetComponentInfo = (): UseGetComponentInfoReturn => {
  const { componentList, selectedId, copiedComponent } = useSelector(
    (state: stateType) => state.questionComponent.present
  )
  
  const selectedComponent = componentList.find(
    (c) => c.fe_id === selectedId
  )
  
  return {
    componentList,
    selectedId,
    selectedComponent,
    copiedComponent,
  }
}

// Usage in component
const { selectedComponent, componentList } = useGetComponentInfo()
```

### 3. Page Info Hooks

```typescript
// hooks/useGetPageInfo.ts
import { useSelector } from 'react-redux'
import type { stateType } from '@/store'

export const useGetPageInfo = () => {
  const pageInfo = useSelector((state: stateType) => state.pageInfo)
  return pageInfo
}

// Usage
const { title, desc, isPublished } = useGetPageInfo()
```

### 4. User Info Hooks

```typescript
// hooks/useGetUserInfo.ts
import { useSelector } from 'react-redux'
import type { stateType } from '@/store'

export const useGetUserInfo = () => {
  const user = useSelector((state: stateType) => state.user)
  return user
}

// Usage
const { username, nickname, token } = useGetUserInfo()
```

### 5. Event Handler Hooks

Pattern for keyboard shortcuts:

```typescript
// hooks/useCanvasKeyPress.ts
import { useEffect } from 'react'
import { useDispatch } from 'react-redux'
import { ActionCreators } from 'redux-undo'
import {
  deleteSelectedComponent,
  copySelectedComponent,
  pasteCopiedComponent,
  selectPrevComponent,
  selectNextComponent,
} from '@/store/modules/question-component'

export const useCanvasKeyPress = () => {
  const dispatch = useDispatch()
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const { key, metaKey, ctrlKey, shiftKey } = e
      const isModifier = metaKey || ctrlKey
      
      // Ignore if typing in input
      const target = e.target as HTMLElement
      if (
        target.tagName === 'INPUT' ||
        target.tagName === 'TEXTAREA' ||
        target.isContentEditable
      ) {
        return
      }
      
      // Undo
      if (isModifier && key === 'z' && !shiftKey) {
        e.preventDefault()
        dispatch(ActionCreators.undo())
        return
      }
      
      // Redo
      if (
        (isModifier && key === 'z' && shiftKey) ||
        (isModifier && key === 'y')
      ) {
        e.preventDefault()
        dispatch(ActionCreators.redo())
        return
      }
      
      // Copy
      if (isModifier && key === 'c') {
        e.preventDefault()
        dispatch(copySelectedComponent())
        return
      }
      
      // Paste
      if (isModifier && key === 'v') {
        e.preventDefault()
        dispatch(pasteCopiedComponent())
        return
      }
      
      // Delete
      if (key === 'Delete' || key === 'Backspace') {
        e.preventDefault()
        dispatch(deleteSelectedComponent())
        return
      }
      
      // Navigate
      if (key === 'ArrowUp') {
        e.preventDefault()
        dispatch(selectPrevComponent())
      }
      
      if (key === 'ArrowDown') {
        e.preventDefault()
        dispatch(selectNextComponent())
      }
    }
    
    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [dispatch])
}

// Usage - just call in component
useCanvasKeyPress()
```

### 6. Navigation Hooks

```typescript
// hooks/useNavPage.ts
import { useNavigate } from 'react-router-dom'
import { useCallback } from 'react'

export const useNavPage = () => {
  const navigate = useNavigate()
  
  const navToList = useCallback(() => {
    navigate('/manage/list')
  }, [navigate])
  
  const navToEdit = useCallback((id: string) => {
    navigate(`/question/edit/${id}`)
  }, [navigate])
  
  const navToStatistics = useCallback((id: string) => {
    navigate(`/question/statistics/${id}`)
  }, [navigate])
  
  const navToPublish = useCallback((id: string) => {
    navigate(`/question/publish/${id}`)
  }, [navigate])
  
  return {
    navToList,
    navToEdit,
    navToStatistics,
    navToPublish,
  }
}

// Usage
const { navToEdit, navToList } = useNavPage()
navToEdit('question-id')
```

### 7. Theme Hooks

```typescript
// hooks/useManageTheme.ts
import { useContext } from 'react'
import { ThemeContext } from '@/contexts/ThemeContext'

export const useManageTheme = () => {
  const context = useContext(ThemeContext)
  
  if (!context) {
    throw new Error('useManageTheme must be used within ThemeProvider')
  }
  
  return context
}

// Usage
const { theme, toggleTheme, setTheme } = useManageTheme()
```

### 8. Scroll Hooks

```typescript
// hooks/useScroll.ts
import { useState, useEffect } from 'react'

interface UseScrollReturn {
  scrollY: number
  scrollX: number
  isScrollingDown: boolean
  isAtTop: boolean
  isAtBottom: boolean
}

export const useScroll = (): UseScrollReturn => {
  const [scrollY, setScrollY] = useState(0)
  const [scrollX, setScrollX] = useState(0)
  const [previousScrollY, setPreviousScrollY] = useState(0)
  
  useEffect(() => {
    const handleScroll = () => {
      setPreviousScrollY(scrollY)
      setScrollY(window.scrollY)
      setScrollX(window.scrollX)
    }
    
    window.addEventListener('scroll', handleScroll, { passive: true })
    return () => window.removeEventListener('scroll', handleScroll)
  }, [scrollY])
  
  return {
    scrollY,
    scrollX,
    isScrollingDown: scrollY > previousScrollY,
    isAtTop: scrollY === 0,
    isAtBottom:
      window.innerHeight + scrollY >= document.documentElement.scrollHeight,
  }
}
```

## Advanced Hook Patterns

### 1. Hook with Cleanup

```typescript
export const useWindowSize = () => {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  })
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      })
    }
    
    window.addEventListener('resize', handleResize)
    
    // Cleanup
    return () => window.removeEventListener('resize', handleResize)
  }, [])
  
  return size
}
```

### 2. Hook with Dependencies

```typescript
export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => clearTimeout(timer)
  }, [value, delay])
  
  return debouncedValue
}

// Usage
const [searchTerm, setSearchTerm] = useState('')
const debouncedSearch = useDebounce(searchTerm, 500)

useEffect(() => {
  // API call with debounced value
  searchQuestions(debouncedSearch)
}, [debouncedSearch])
```

### 3. Hook with Ref

```typescript
export const usePrevious = <T>(value: T): T | undefined => {
  const ref = useRef<T>()
  
  useEffect(() => {
    ref.current = value
  }, [value])
  
  return ref.current
}

// Usage
const [count, setCount] = useState(0)
const previousCount = usePrevious(count)
```

### 4. Hook with Callback

```typescript
export const useToggle = (
  initialValue = false
): [boolean, () => void, (value: boolean) => void] => {
  const [value, setValue] = useState(initialValue)
  
  const toggle = useCallback(() => {
    setValue((v) => !v)
  }, [])
  
  const set = useCallback((newValue: boolean) => {
    setValue(newValue)
  }, [])
  
  return [value, toggle, set]
}

// Usage
const [isOpen, toggleOpen, setOpen] = useToggle(false)
```

### 5. Hook with Multiple States

```typescript
interface UseFormReturn<T> {
  values: T
  errors: Record<keyof T, string>
  touched: Record<keyof T, boolean>
  handleChange: (field: keyof T, value: any) => void
  handleBlur: (field: keyof T) => void
  handleSubmit: (onSubmit: (values: T) => void) => void
  reset: () => void
}

export const useForm = <T extends Record<string, any>>(
  initialValues: T
): UseFormReturn<T> => {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Record<keyof T, string>>({} as any)
  const [touched, setTouched] = useState<Record<keyof T, boolean>>({} as any)
  
  const handleChange = useCallback((field: keyof T, value: any) => {
    setValues((prev) => ({ ...prev, [field]: value }))
  }, [])
  
  const handleBlur = useCallback((field: keyof T) => {
    setTouched((prev) => ({ ...prev, [field]: true }))
  }, [])
  
  const handleSubmit = useCallback(
    (onSubmit: (values: T) => void) => {
      onSubmit(values)
    },
    [values]
  )
  
  const reset = useCallback(() => {
    setValues(initialValues)
    setErrors({} as any)
    setTouched({} as any)
  }, [initialValues])
  
  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  }
}
```

## Hook Testing

### Testing Custom Hooks

```typescript
import { renderHook, act } from '@testing-library/react'
import { useToggle } from './useToggle'

describe('useToggle', () => {
  it('should toggle boolean value', () => {
    const { result } = renderHook(() => useToggle(false))
    const [value, toggle] = result.current
    
    expect(value).toBe(false)
    
    act(() => {
      toggle()
    })
    
    expect(result.current[0]).toBe(true)
  })
})
```

## Best Practices

1. **Single Responsibility**: Each hook should do one thing well
2. **Return Object vs Array**: Use object for multiple related values, array for simple pairs
3. **Memoization**: Use `useCallback` and `useMemo` to prevent unnecessary re-renders
4. **Dependencies**: Always include all dependencies in useEffect/useCallback
5. **Error Handling**: Handle errors gracefully in data fetching hooks
6. **Loading States**: Always provide loading state for async operations
7. **Cleanup**: Clean up side effects (event listeners, timers, subscriptions)
8. **TypeScript**: Properly type all hook parameters and return values
9. **Documentation**: Add JSDoc comments for complex hooks
10. **Reusability**: Make hooks generic and reusable when possible

## Common Patterns

### Loading Pattern
```typescript
const { loading, error, data } = useLoadData()

if (loading) return <Spinner />
if (error) return <Error message={error.message} />
return <Content data={data} />
```

### Selector Pattern
```typescript
const data = useSelector((state: stateType) => state.module.data)
```

### Dispatch Pattern
```typescript
const dispatch = useDispatch()
dispatch(actionCreator(payload))
```

### Navigation Pattern
```typescript
const navigate = useNavigate()
navigate('/path')
```

## Hooks Checklist

When creating a new hook:
- [ ] Name starts with `use`
- [ ] Has proper TypeScript types
- [ ] Returns consistent data structure
- [ ] Handles loading/error states (if async)
- [ ] Cleans up side effects
- [ ] Uses useCallback/useMemo where appropriate
- [ ] Has proper dependency arrays
- [ ] Is placed in `src/hooks/` directory
- [ ] Is exported from the hooks directory
- [ ] Has JSDoc comments if complex
